---
title: "WPCA"
author: "Yuheng Ma"
date: "9/8/2020"
output:
  pdf_document: default
  html_document: default
---

## High dimentional factor estimation

Direct implementation of (dynamic) factor models estimation methods, mainly weighted PCA method. 

Parameter settings:
N the number of time series
T the length of time series
q the chosen number of factors
W the weight matrix
sigmainv the precision matrix
X=(x_1,..,x_T)' the observation with dim N*T
F=(f_1,..,f_T)' the factors with dim T*q
B the loading matrix with dim N*q
C a hyperparameter that needs Cross validation
~hat stands for estimation of ~

```{r}
# functions needed
library(MASS)
argmin<-function(y,index=NULL){
  index=seq(length(y))
  return(index[which(y==min(y))[1]])
}

largesteigen<-function(A,q,ifvalue=0){
  # given a matrix A, return largest q eigenvectors (as colmumns in a matrix)
  values<-eigen(A,symmetric = TRUE)$values
  vectors<-eigen(A,symmetric = TRUE)$vectors
  N<-dim(A)[1]
  ifeigenvalue<-{order(values)>N-q}
  ifeigenvector<-which(ifeigenvalue!=0)
  if(ifvalue==1){return(values[ifeigenvalue])}
  return(vectors[,ifeigenvector])
}
```


```{r}
wpca<-function(W,X,N,T,q){
  # do wpca assuming that q is known
  # set W=diag(N) is just PCA method
  if(dim(X)[2]!=T||dim(X)[1]!=N){return("Data dim error")}
  Fhat<-largesteigen(t(X)%*%W%*%X/sqrt(T),q)
  Bhat<-X%*%Fhat
  #Bhat<-X%*%Fhat/T
  return(list(Fhat,Bhat))
}
```

```{r}
library(tseries)
library(MARSS)
#x data set，n number of factors，states is the estimaton
marss.dfm=function(x,n){
  MARSS.data=x
  n.indi=nrow(x)
  n.state=n     ######definiting numbers of states
  Z=matrix(NA,n.indi,n.state)
  for(i in 1:(n.state)){
    for(j in 1:(n.indi)){
      Z[j,i]=paste("z",j,"-",i,sep="")
    }
  }
  B=matrix(NA,n.state,n.state)
  for(i in 1:(n.state)){
    for(j in 1:(n.state)){
      B[j,i]=paste("b",j,"-",i,sep="")
    }
  }
  U=matrix(NA,n.state,1)
  for(i in 1:(n.state)){
    U[i,1]=paste("u",i,"-",1,sep="")
  }
  A=matrix(NA,n.indi,1)
  for(i in 1:(n.indi)){
    A[i,1]=paste("a",i,"-",1,sep="")
  }
  Q="diagonal and unequal"
  R="diagonal and unequal"
  Iinit=list(Z=0.5,
             B=0.5,
             U=0,
             Q=0.5,
             A=0.5,
             R=0.5,
             x0=0.5,
             V0=0
  )
  result.marss.init=MARSS(y=MARSS.data,model=list(Z=Z,A=A,B=B,U=U,Q=Q,R=R),inits=Iinit,silent=TRUE)
  result.marss.exact=MARSS(y=MARSS.data,model=list(Z=Z,A=A,B=B,U=U,Q=Q,R=R),inits=result.marss.init$par,silent=TRUE)
  result.marss=MARSS(y=MARSS.data,model=list(Z=Z,A=A,B=B,U=U,Q=Q,R=R),inits=result.marss.exact$par,silent=TRUE)
  return(result.marss)
}
```


```{r}
# covariance matrix estimation
# provided in the paper
covestimation<-function(X,N,T,q,C){
  if(dim(X)[2]!=T||dim(X)[1]!=N){return("Data dim error")}
  samplecov<-cov(t(X))
  mainpart<-largesteigen(samplecov,q)%*%diag(largesteigen(samplecov,q,1))%*%t(largesteigen(samplecov,q))
  
  R<-samplecov-mainpart
  
  for (i in 1:N){
    if(-0.00001<R[i,i]&&R[i,i]<0){R[i,i]=0}
  }
  for (i in 1:N) {
    for (j in 1:N){
      if(i!=j){
        R[i,j]<-R[i,j]*{abs(R[i,j])>C*sqrt(R[i,i]*R[j,j]*{sqrt(log(N)/T)+1/sqrt(N)})}
      }
    }
  }
  return(R+mainpart)
}
```




```{r}
# funcion that specify q 
# details in "Determining the number of factors in approximate factor model" by Bai and Ng.
specifyq<-function(X,N,T,range=0,C){
  if(dim(X)[2]!=T||dim(X)[1]!=N){return("Data dim error")}
  if(range==0){
  range<-c(2:10)
  }
  Khat<-seq(length(range))
  for (i in 1:length(range)){ 
    W<-ginv(covestimation(X,N,T,range[i],C))
    Fhat<-wpca(W,X,N,T,range[i])[[1]]
    mat<-X-{X%*%Fhat%*%t(Fhat)}/T
    Khat[i]<-log(sum(diag(t(mat)%*%mat))/N/T)+i*{N+T}*log(N*T/{N+T})/{N*T}
  }
  print(Khat)
  return(range[argmin(Khat)])
}
```

```{r}
# put everything together
# assuming C is known
# C will be determined by cross validation, and is empirically set to 1
factorestimation<-function(X,N,T,q=0,C,method="EPCA",ifprint=1){
  if(length(q)==1){
  if(q==0){
  q<-specifyq(X,N,T,C=C)
  #print("q")
  #print(q)
  }
    else{
  #q<-specifyq(X,N,T,q,C)
      if(ifprint==1){
  #print("q")
  #print(q)
        }
  }
  }
  if(length(q)!=1){
    q<-specifyq(X,N,T,q,C)
  #print("q")
  #print(q)
  }
  if(method=="WPCA"){W<-ginv(covestimation(X=X,N=N,T=T,q=q,C=C))}
  if(method=="WPCAdiagonal"){W<-ginv(diag(diag(cov(t(X)))))
  }
  if(method=="EPCA"){W<-ginv(cov(t(X)))}
  if(method=="PCA"){W<-diag(N)}
  result<-wpca(W=W,X=X,N=N,T=T,q=q)
  prediction<-result[[2]]%*%t(result[[1]])

  #preerror<-prediction-X
  return(result)
}
```



```{r}
## real data experiment 
setwd("/Users/mayuheng/Desktop/DFM/Recent2/data_dfm")
data<-read.csv("681data.csv")
depvar<-read.csv("mid.csv",encoding="UTF-8")
depvar<-read.csv("input.csv")
colnames(data)<-NULL
rownames(data)<-NULL
data[,1]<-NULL
data<-apply(data,2,as.numeric)

```

```{r}
lireg<-function(method,dep,C){
  #use determined factor to regress
  q=8
result<-factorestimation(t(data),681,180,q=q,C=C,method = method)
Fhat<-as.data.frame(result[[1]])
Fhat<-cbind(Fhat,depvar[,dep])
colnames(Fhat)[q+1]<-"input"
inputlinear<-lm(input~.,Fhat)
print(summary(inputlinear)$r.squared)
}
```

Real data application functions.

```{r}
# foreward prediction using vector autoregressive model
varpre<-function(n,Fhat,lag){
  Fhat<-as.data.frame(Fhat)
  varmodel<-VAR(Fhat[1:n,],lag.max = lag)
  pre<-predict(varmodel,n.ahead = 12,ci=0.95)
  result<-NULL
  for (i in 1:ncol(Fhat)){
    result<-cbind(result,pre$fcst[[i]][,1])
  }
  return(result)
}

```

```{r}
sumof<-function(A,k){
  A<-as.matrix(A)
  n<-dim(A)[1]/k
  result<-NULL
  for (i in 1:n) {
    result<-rbind(result,apply(A[{k*i-k+1}:{k*i},], MARGIN = 2, sum))
  }
  return(result)
}
```

```{r}
rmse<-function(A,B){
  A<-as.matrix(A)
  B<-as.matrix(B)
  temp<-{A-B}*{A-B}
  temp<-sum(temp)
  temp<-temp/dim(A)[1]/dim(A)[2]
  return(sqrt(temp))
}
```

```{r}
# prediction function for wpca itself
evaluateprewpca<-function(data,depvar,year,q,C,var=1:12){
  year=year-1
  T=year*12
  deltaM<-depvar[13:T,]-depvar[1:{T-12},]
    factorspre<-factorestimation(t(data)[,1:{{year}*12}],681,{year}*12,q,C,"WPCAdiagonal")[[1]]
        pre<-varpre(year*12,factorspre,1)
    
  predfactors<-cbind(rep(1,12),pre)
  
  predresult<-NULL
  for (ii in var) {
    fit<-as.data.frame(cbind(deltaM[,ii],factorspre[13:T,]))
    
    lmodel<-lm(V1~.,fit)
    coef<-matrix(lmodel$coefficients,ncol = 1)
    predresult<-cbind(predresult,predfactors%*%coef)
  }
  predresult<-predresult+depvar[{T-11}:T,]
  return(predresult)
}
``` 


```{r}
#using arima for comparison
evaluateprearima<-function(depvar,year,var=1:12){
  year=year-1
  T=year*12
  predresult<-NULL
  deltaM<-depvar[13:T,]-depvar[1:{T-12},]
    for (i in var) {
      amodel<-arima(deltaM[,i],order = c(1,0,0))
      pre<-forecast(amodel,h=12)
      predresult<-cbind(predresult,as.numeric(pre$mean))
    }
  predresult<-predresult+depvar[{T-11}:T,]
  return(predresult)
}

```



```{r}
#depvar is depvar
#T length of depvar, default set to 180
# note that must be multiple of 12
#method={ASPCA,PCAMARSS,ASPCAMARSS}
#q the number of common factors
#result the corresponding MARSS object if required
#note that length of result$states must be compatible with T-12 (if ifdiff=1) or T (if =0)
#ifdiff the flag variable, =1 if using differencing, -0 if not
#numdepvar the number of midinput
#ifprint the flag variable, set to 1 if need to print summary of lm (read R^2)
#wavelet the parameter needed by aspca
evaluatefit<-function(depvar,method,q,T=180,result=0,ifdiff=1,numdepvar=9,ifprint=0,wavelet=0){
  deltaMfit<-NULL
  depvarfit<-NULL
  #differencing
  deltaM=depvar[1:{T-12},]-depvar[13:T,]
  if(method=="PCAMARSS"||method=="ASPCAMARSS"){
    if(ifdiff==1){
      for (t in 1:numdepvar) {
        #do regression
        fitdeltaM<-as.data.frame(cbind(deltaM[,t],t(result$states)))
        mmodel<-lm(V1~.,fitdeltaM)
        if(ifprint==1){print(summary(mmodel))}
        deltaMfit<-cbind(deltaMfit,mmodel$fitted.values)
      }
      depvarfit<-deltaMfit+depvar[1:{T-12},]
      return(depvarfit)
    }
    if(ifdiff==0){
      for (t in 1:numdepvar) {
        #do regression
        fit<-as.data.frame(cbind(depvar[1:T,t],t(result$states)))
        mmodel<-lm(V1~.,fitdeltaM)
        if(ifprint==1){print(summary(mmodel))}
        depvarfit<-cbind(depvarfit,mmodel$fitted.values)
      }
      return(depvarfit)
    }
  }
  if(method=="ASPCA"){
    alpha=wavelet[1]
    beta=wavelet[2]
    itthres=-5
    q=wavelet[3]
    ##############################################
    setwd("/Users/mayuheng/Desktop/DFM/PCs")
    
    data<-read.csv(paste("result","a",as.character(alpha),"b",as.character(beta),"i",as.character(itthres),"q",as.character(q),".csv",sep = ""),header = FALSE)
    ##note that data generally need modification########
    data<-data[25:204,]
    ### check!!!!!!!!!!!!!!!!!#######################
    if(ifdiff==1){
      for (t in 1:numdepvar) {
        #do regression
        fitdeltaM<-as.data.frame(cbind(deltaM[,t],data))
        mmodel<-lm(V1~.,fitdeltaM)
        if(ifprint==1){print(summary(mmodel))}
        deltaMfit<-cbind(deltaMfit,mmodel$fitted.values)
      }
      depvarfit<-deltaMfit+depvar[1:{T-12},]
      return(depvarfit)
    }
    if(ifdiff==0){
      for (t in 1:numdepvar) {
        #do regression
        fit<-as.data.frame(cbind(depvar[1:T,t],data))
        mmodel<-lm(V1~.,fitdeltaM)
        if(ifprint==1){print(summary(mmodel))}
        depvarfit<-cbind(depvarfit,mmodel$fitted.values)
      }
      return(depvarfit)
    }
  }
}
```

```{r}
#default using differencing
#T must correspond to result obeject T=len(result)+12
#depvar 中间投入 
#T 时间长度
evaluatepre<-function(result,data=0,depvar,T,q,step=36,var=1:9){
  if(dim(result$states)[2]!=T-12){return("time length error")}
  deltaM<-depvar[13:T,]-depvar[1:{T-12},]
  if(data!=0){
    #factorspre<-factorestimation(t(data)[,1:T],681,T,q,1,"WPCAdiagonal")[[1]]
    result=marss.dfm(data,q)
  }
  predresult<-NULL
  pre<-predict(result,n.ahead = step,type = "xtT")
  predfactors<-matrix(rep(0,step*q),ncol = q)
  for (i in 1:q) {
    for (j in 1:step) {
      predfactors[j,i]<-pre$pred$estimate[{i-1}*{T-12+step}+j+{T-12}]
    }
  }
  predfactors<-cbind(rep(1,step),predfactors)
  for (ii in var) {
    fit<-as.data.frame(cbind(deltaM[,ii],t(result$states)[1:{T-12},]))
    
    lmodel<-lm(V1~.,fit)
    coef<-matrix(lmodel$coefficients,ncol = 1)
    predresult<-cbind(predresult,predfactors%*%coef)
  }
  colnames(predresult)<-colnames(depvar)
  predresult<-rbind(depvar[1:T,],predresult)
  for (iii in 1:step) {
    predresult[T+iii,]=predresult[T+iii-12,]+predresult[T+iii,]
  }
  return(predresult[{T+1}:{T+step},])
  #return(predresult)
}

```

```{r}
q=10
preforward=36
alpha=6
beta=5
itthres=-5
path<-getwd()



depvartrain<-depvartrain[1:180,]
for (k in 1:preforward) {
  print(k)
    filename<-paste("/PCs/result","iter",as.character(k),"a",as.character(alpha),"b",as.character(beta),"i",as.character(itthres),"q",as.character(q),".csv",sep = "")
    pathname<-paste(path,filename,sep = "")

 # while (!file.exists(pathname)) {
  #  Sys.sleep(1)
   # print("File does not exist")
  #}
  data<-read.csv(pathname,header = FALSE)
  data<-as.matrix(data)
  result<-marss.dfm(t(data),q)
  
  depvartrain<-rbind(depvartrain,as.matrix(evaluatepre(result = result,depvar = depvartrain,T=179+k,q=q,step = 1)))
} 

```

```{r}
# dynamic pca method
dpca<-function(X,N,T,q=0,C=1,method="EPCA",window=6){
  Fhat<-NULL
  for (i in 1:T){
    if(i%%10==0){print(i)}
    winstart<-max(i-window+1,1)
    winend<-min(i+window-1,T)
    t=winend-winstart+1
    Fhatwindow<-factorestimation(X[,winstart:winend],N=N,T=t,q=q,C=C,method=method,ifprint = 0)[[1]]
    print(dim(Fhatwindow))
    #print(winstart)
    Fhat<-rbind(Fhat,Fhatwindow[i-winstart+1,])
  }
  return(Fhat)
}
```

```{r}
depvar<-read.csv("./Prediction_Task/data/0217.csv",encoding="UTF-8")
depvar[,1]<-NULL
depvar<-as.data.frame(depvar)
deltadepvar=depvar[13:192,]-depvar[1:180,]
#depvar=sumof(depvar,3)
arimaresult=deltadepvar
for (i in 1:9) {
  for (j in seq(84,168,12)) {
    seqused=deltadepvar[1:j,i]
    for (k in 1:12) {
      
    
  
  #arimamodel<-auto.arima(seqused,d=1,max.p = 13,max.q = 13)
  arimamodel<-arima(seqused,order=c(1,1,1))
  arimaresult[j+k,i]=forecast(arimamodel)$mean[1]
  seqused=c(seqused,forecast(arimamodel)$mean[1])
  }
  }
}
arimaresult=arimaresult+depvar[1:180,]

sqrt(sumof((sumof(arimaresult,12)-sumof(depvar,12))**2,16)/16)/sumof(depvar,12)[1,]
write.csv(sumof(arimaresult,12),"added_month_arima.csv")
#sqrt(sumof((arimaresult-depvar)**2,12)/12)
#sum(abs(sumof((arimaresult-depvar)/depvar,12)))
```


```{r}
depvar<-read.csv("./Prediction_Task/data/final_use_month_adjust.csv",encoding="UTF-8")
depvar[,1]<-NULL
depvar<-as.data.frame(depvar)
depvar=sumof(depvar,3)
arimaresult=depvar
for (i in 1:9) {
  for (j in seq(32,60,4)) {
    seqused=depvar[1:j,i]
    for (k in 1:4) {
      
    
  
  arimamodel<-auto.arima(seqused,d=1,max.p = 13,max.q = 13)
  arimaresult[j+k,i]=forecast(arimamodel)$mean[1]
  seqused=c(seqused,forecast(arimamodel)$mean[1])
  }
  }
}
(arimaresult-depvar)[33:64,]/(depvar)[33:64,]

sqrt(sumof((sumof(arimaresult,4)-sumof(depvar,4))**2,16)/16)/sumof(depvar,4)[1,]

sqrt(sumof((arimaresult-depvar)**2,12)/12)
sum(abs(sumof((arimaresult-depvar)/depvar,12)))
```



```{r}
depvar<-read.csv("./Prediction_Task/data/added_value.csv",encoding="UTF-8")
depvar[,1]<-NULL
depvar<-as.data.frame(depvar)
depvar=sumof(depvar,3)
deltadepvar=depvar[5:64,]-depvar[1:60,]
arimaresult=deltadepvar
for (i in 1:9) {
  for (j in seq(28,56,4)) {
    seqused=deltadepvar[1:j,i]
    for (k in 1:4) {
    
  arimamodel<-auto.arima(seqused,max.p = 13,max.q = 13)
  arimaresult[j+k,i]=forecast(arimamodel)$mean[1]
  seqused=c(seqused,forecast(arimamodel)$mean[1])
  }
  }
}

arimaresult=arimaresult+depvar[1:60,]
(arimaresult[29:60,]-depvar[33:64,])/(depvar)[33:64,]

sqrt(sumof((sumof(arimaresult,4)-sumof(depvar,4))**2,16)/16)/sumof(depvar,4)[1,]

sqrt(sumof((arimaresult-depvar)**2,12)/12)
sum(abs(sumof((arimaresult-depvar)/depvar,12)))
```



```{r}
#T 时间长度
evaluatepre<-function(result,data=0,depvar,T,q,step=36,var=1:9){
  if(dim(result$states)[2]!=T-12){return("time length error")}
  deltaM<-depvar[13:T,]-depvar[1:{T-12},]
  if(data!=0){
    #factorspre<-factorestimation(t(data)[,1:T],681,T,q,1,"WPCAdiagonal")[[1]]
    result=marss.dfm(data,q)
  }
  predresult<-NULL
  pre<-predict(result,n.ahead = step,type = "xtT")
  predfactors<-matrix(rep(0,step*q),ncol = q)
  for (i in 1:q) {
    for (j in 1:step) {
      predfactors[j,i]<-pre$pred$estimate[{i-1}*{T-12+step}+j+{T-12}]
    }
  }
  predfactors<-cbind(rep(1,step),predfactors)
  for (ii in var) {
    fit<-as.data.frame(cbind(deltaM[,ii],t(result$states)[1:{T-12},]))
    
    lmodel<-lm(V1~.,fit)
    coef<-matrix(lmodel$coefficients,ncol = 1)
    predresult<-cbind(predresult,predfactors%*%coef)
  }
  colnames(predresult)<-colnames(depvar)
  predresult<-rbind(depvar[1:T,],predresult)
  for (iii in 1:step) {
    predresult[T+iii,]=predresult[T+iii-12,]+predresult[T+iii,]
  }
  return(predresult[{T+1}:{T+step},])
  #return(predresult)
}

```



```{r}
setwd("/Users/mayuheng/Documents/GitHub/DFM/Prediction_Task")
data<-read.csv("./data/hidata.csv",encoding="UTF-8")
data[,1]<-NULL
#data<-data[25:240,]
data<-as.matrix(data)




depvar1<-read.csv("./import.csv",encoding="UTF-8")
depvar1[,1]<-NULL
depvar1<-as.data.frame(depvar1)
depvartrain1<-depvar1
depvar2<-read.csv("./data/added_value.csv",encoding="UTF-8")
depvar2[,1]<-NULL
depvar2<-as.data.frame(depvar2)
depvartrain2<-depvar2
depvar3<-read.csv("./data/final_use_month_adjust.csv",encoding="UTF-8")
depvar3[,1]<-NULL
depvar3<-as.data.frame(depvar3)
depvartrain3<-depvar3
preforward=c(36,24,36,24,24)
usetopre=c(72,108,132,168,192)
depvarsave1<-NULL
depvarsave2<-NULL
depvarsave3<-NULL
for (y in 1:4){

  depvartrain1=depvar1[1:usetopre[y],]
  depvartrain2=depvar2[1:usetopre[y],]
  depvartrain3=depvar3[1:usetopre[y],]
  

  for (j in 1:preforward[y]) {
    print(j)
    depvartrain1=rbind(depvartrain1,rep(0,9))
    depvartrain2=rbind(depvartrain2,rep(0,9))
    depvartrain3=rbind(depvartrain3,rep(0,9))
    prefactors<-factorestimation(t(data[1:{usetopre[y]+j},]),2141,usetopre[y]+j,q=3,C,method="PCA",ifprint=0)[[1]]
    
    factors=prefactors[1:{usetopre[y]+j-1},]
    prefactors<-matrix(prefactors[usetopre[y]+j,],nrow =1)
    for (i in 1:9) {
  seqused=depvartrain1[1:{usetopre[y]+j-1},i]
  #arimamodel<-auto.arima(seqused,d=1,max.p = 13,max.q = 13,xreg = factors*sqrt(usetopre[y]+j-1))
  arimamodel<-auto.arima(seqused,d=1,max.p = 13,max.q = 13)
  
  #depvartrain1[j+usetopre[y],i]=forecast(arimamodel,xreg = prefactors*sqrt(usetopre[y]+j-1))$mean[1]
  depvartrain1[j+usetopre[y],i]=forecast(arimamodel)$mean[1]
  #seqused=depvartrain2[1:{usetopre[y]+j-1},i]
  #arimamodel<-auto.arima(seqused,d=1,max.p = 13,max.q = 13,xreg = factors*sqrt(usetopre[y]+j-1))
  #depvartrain2[j+usetopre[y],i]=forecast(arimamodel,xreg = prefactors*sqrt(usetopre[y]+j-1))$mean[1]
  #seqused=depvartrain3[1:{usetopre[y]+j-1},i]
  #arimamodel<-auto.arima(seqused,d=1,max.p = 13,max.q = 13,xreg = factors*sqrt(usetopre[y]+j-1))
  #depvartrain3[j+usetopre[y],i]=forecast(arimamodel,xreg = prefactors*sqrt(usetopre[y]+j-1))$mean[1]
  
  
  }
}

  index=dim(depvartrain1)[1]
  depvarsave1=rbind(depvarsave1,depvartrain1[{index-11}:index,])
  depvarsave2=rbind(depvarsave2,depvartrain2[{index-11}:index,])
  depvarsave3=rbind(depvarsave3,depvartrain3[{index-11}:index,])
}
#write.csv(sumof(depvarsave1,12),"midinputarima.csv")
#write.csv(sumof(depvarsave2,12),"addedarima.csv")
#write.csv(sumof(depvarsave3,12),"finalusearima.csv")
```



```{r}
setwd("/Users/mayuheng/Documents/GitHub/DFM/Prediction_Task")
added<-read.csv("./data/added_value.csv",encoding="UTF-8")
added[,1]<-NULL
import<-read.csv("./data/import.csv",encoding="UTF-8")
import[,1]<-NULL
importmonth<-matrix(rep(0,9*16*12),ncol = 9)
for (i in 1:16) {
  for (j in 1:12) {
    for (k in 1:9) {
      
    
    importmonth[i*12-12+j,k]=import[i,k]*added[i*12-12+j,k]/sumof(added,12)[i,k]
    }
  }
}

```
```{r}
```{r}
q=10
data<-read.csv("./data/hidata.csv",encoding="UTF-8")
data[,1]<-NULL
data<-data[25:240,]
data<-as.matrix(data)
setwd(".")
depvar1<-read.csv("./data/0217.csv",encoding="UTF-8")
depvar1[,1]<-NULL
depvar1<-as.data.frame(depvar1)
depvartrain1<-depvar1
depvar2<-read.csv("./data/added_value.csv",encoding="UTF-8")
depvar2[,1]<-NULL
depvar2<-as.data.frame(depvar2)
depvartrain2<-depvar2
depvar3<-read.csv("./data/final_use_month_adjust.csv",encoding="UTF-8")
depvar3[,1]<-NULL
depvar3<-as.data.frame(depvar3)
depvartrain3<-depvar3
depvar4<-read.csv("./data/import.csv",encoding="UTF-8")
depvar4[,1]<-NULL
depvar4<-as.data.frame(depvar4)
depvartrain4<-depvar4
#preforward=c(36,24,36,24,24)
preforward=c(36,24,36,24,36)-12
#preforward=c(24,12,24)
usetopre=c(72,108,132,168,192)
#usetopre=c(48,192,192)
depvarsave1<-NULL
depvarsave2<-NULL
depvarsave3<-NULL
depvarsave4<-NULL
for (i in 4){


  depvartrain1=depvar1[1:usetopre[i],]
  #depvartrain2=depvar2[1:usetopre[i],]
  #depvartrain3=depvar3[1:usetopre[i],]
  #depvartrain4=depvar4[1:usetopre[i],]
for (k in 1:preforward[i]) {
  print(k)
  
  factors<-factorestimation(t(data[1:{usetopre[i]+k-1},]),2141,{usetopre[i]+k-1},q=q,C=1,method = "PCA")[[1]]

  factors<-as.matrix(factors)
  result<-marss.dfm(t(factors),q)

  depvartrain1<-rbind(depvartrain1,as.matrix(evaluatepre(result = result,depvar = depvartrain1,T=usetopre[i]+k-1,q=q,step = 1)))
 #depvartrain2<-rbind(depvartrain2,as.matrix(evaluatepre(result = result,depvar = depvartrain2,T=usetopre[i]+k-1,q=q,step = 1)))
 #depvartrain3<-rbind(depvartrain3,as.matrix(evaluatepre(result = result,depvar = depvartrain3,T=usetopre[i]+k-1,q=q,step = 1)))
 #depvartrain4<-rbind(depvartrain4,as.matrix(evaluatepre(result = result,depvar = depvartrain4,T=usetopre[i]+k-1,q=q,step = 1)))
  #print(depvartrain)
} 

  index=dim(depvartrain1)[1]
  depvarsave1=rbind(depvarsave1,depvartrain1[{index-preforward[i]}:index,])
  #depvarsave2=rbind(depvarsave2,depvartrain2[{index-11}:index,])
  #depvarsave3=rbind(depvarsave3,depvartrain3[{index-11}:index,])
  #depvarsave4=rbind(depvarsave4,depvartrain4[{index-11}:index,])
}
#write.csv(depvarsave1,"midinputpca.csv")
#write.csv(depvarsave2,"addedpca.csv")
#write.csv(depvarsave3,"finalusepca.csv")
#write.csv(depvarsave4,"importpca.csv")
```
```

